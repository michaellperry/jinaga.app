# Your First App

Your first Jinaga app will be in the public folder, so that anybody can access it without logging in.
You'll set up a connection to the back end, and then create view models to edit entities. You will
bind these to the view using KnockoutJS.

## Connect to the Back End

In the public folder, you created `myapp.js`. Open this again and create an instance of `Jinaga`. Sync
it with the distributor on the back end.

```JavaScript
var j = new Jinaga();
j.sync(new JinagaDistributor(distributorUrl));
```

The `distributorUrl` variable is defined in `config.js`, which is generated by the back end.

### Bind to synchronization status

Add some observables to your view model to keep track of synchronization status. The Jinaga Knockout
helper has a method to do that. Add this call to the MainViewModel constructor:

```JavaScript
jko.observeStatus(this);
```

Now bind those observables to the view. You will want to view the `status` and `error` properties:

```HTML
<div class="row">
  <div class="columns large-2"><span data-bind="text: status"></span></div>
  <div class="columns large-10"><span data-bind="text: error"></span></div>
</div>
```

With the back end running, refresh the page and see if the status message flashes. You can test the status
by stopping the back end. It should change to "Error". Start the back end again and the status will disappear.

## Root View Model

The main view model is for page-level properties. It doesn't contain domain information. Let's go down
one level and create a view model for the root of our domain. In this example, we will be talking about
a user group. First define a fact for the user group. Add this inside the MainViewModel constructor.

```JavaScript
var userGroup = {
  type: 'MyApp.UserGroup',
  identifier: 'papersdallas'
};
```

Then create a property of the main view model:

```JavaScript
this.userGroup = new UserGroupViewModel(userGroup);
```

### View model class

Below the MainViewModel function, you can define another function for the UserGroupViewModel constructor:

```JavaScript
function UserGroupViewModel(userGroup) {
}
```

### Mutable properties

A user group has a name. Define that as a mutable property inside of the UserGroupViewModel constructor:

```JavaScript
this.name = new jko.Mutable('MyApp.UserGroup.Name', userGroup, '');
```

The first parameter is the type of the fact representing the mutable property's value. Use the convention
`Application.Entity.Property`.

The second parameter is the entity fact itself.

The third parameter is the default value of the property. Use this to indicate the type of the property.
Use `''` for strings, `0` for numbers, `{}` for objects, or 'null' for nullable objects.

*Take a peek [under the covers](https://github.com/michaellperry/jinaga.app/blob/master/Mutable.md).*

### Watching mutable properties

Create a function to watch for facts matching the generated template functions. Define this on the
UserGroupViewModel prototype:

```JavaScript
UserGroupViewModel.prototype.watch = function () {
  this.name.watch();
};
```

As you add new Mutables to the class, add a call to their `watch` function as well.

Call this function after you create the UserGroupViewModel in the MainViewModel constructor:

```JavaScript
this.userGroup.watch();
```

### Binding to mutable properties

Back in the HTML, you'll want to bind to the `userGroup` property of the main view model. Then inside
of that block, bind to the `name` mutable property. The `value` sub-property gives you access to the
current value.

```HTML
<div data-bind="with: userGroup">
  <input type="text" data-bind="value: name.value">
</div>
```

Keep the back end running as you build the app. You can test it now by simply refreshing the page. Change
the user group's name, tab out, and refresh to see that it was persisted. Open the page in another browser,
and see that it updates on one browser when you change it in the other.

## Child View Model
